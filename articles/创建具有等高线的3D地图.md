![图](http://p0.qhimg.com/t018589e8aae0b414b8.png)

> 几周前，我研究了等高线和水体的 3D 地图。结果非常好，所以我决定写一个关于我如何构建它的教程.

### 1.准备数据

该地图数据源是从 SRTM 数据生成的等高线，水体数据来自 OpenStreetMap，山体数据来自瑞士联邦地形办公室 Swisstopo 出版的数据集 swissNAMES3D。前两个来源涵盖了世界各地，而第三个来源是瑞士特有的，你也可以使用你感兴趣的任何地区的数据。

#### 等高线

让我们导航到[OpenDEM](https://opendem.info/opendem_client.html)网站，在那里他们有从 SRTM 数据生成的整个世界的等高线。导航到你感兴趣的区域并下载包含它的瓦片数据。

在 ArcGIS Pro 中加载数据并将其重新投影到投影坐标系（对于瑞士，我使用了 [LV95](https://epsg.io/2056),它是瑞士地区专有投影）。然后将等高线剪切到仅包含你感兴趣区域的较小区域。通常，太大的区域处理效率不高。对于苏黎世，我决定根据我在另一层创建的圆形多边形来剪切它们。你还可以将它们剪切到某个矩形边框或其他形状。保持 elevation 属性非常重要，因为我们将使用它来将高度特征与地面对齐。最后，等高线看起来像这样：

![图片](http://p0.qhimg.com/t0105671ed6fc08ca44.png)

#### 水体

接下来我们将下载 OpenStreetMap 数据（我从 Geofabrik 下载了瑞士的整个数据集），然后在 ArcGIS Pro 中加载多边形水体。首先，我们将它重新投影到 LV95，然后我们裁剪出所需区域的水体数据。我希望仅包含 fclass 属性设置为 water 的数据 。从河流中我只保留了 Limmat，这是最大的一个。然后，我通过使用“计算几何”计算属性中的区域并选择面积大于某个阈值的所有要素来选择主要水体。某些功能在数据集中出现两次，因此我通过应用“ 删除相同”工具删除了重复项 osm_id 字段。经过严格的选择后，我的数据集中只有 9 条数据：

![图片](http://p0.qhimg.com/t01f04b096f5f1da87e.png)

#### 山体

原始的 swissNAMES3D 数据可以在[swisstopo](https://shop.swisstopo.admin.ch/en/products/landscape/names3D)找到。我下载并将数据剪裁为圆形。然后我开始过滤点：我只保留了 OBJEKTART = Huegel 的山体数据，我手动删除了不是主要山峰的点，就像这张图片中的选定点:

![图片](http://p0.qhimg.com/t010363d6ce305f38c0.png)

此数据集中的点具有 z 值，我们将使用这些值进行高程对齐。我删除了大部分不需要的 属性字段，但保留了 NAME 字段以用于标记。处理之后，数据集包含 45 个山峰：

![图片](http://p0.qhimg.com/t017168c0e63603f9c4.png)

在这些预处理步骤之后，我们现在可以将三个数据集作为要素图层发布到 ArcGIS Online 上，我发布的数据图层链接如下所示：

- 等高线图层： https://zurich.maps.arcgis.com/home/item.html?id=c9e39a799fd44255a42f567fb1457f29
- 山体图层： https://zurich.maps.arcgis.com/home/item.html?id=e0aa24dd8df44d909cf12aa4a78e457d
- 水体图层： https://zurich.maps.arcgis.com/home/item.html?id=75306717ac2847b39845b9931405793c

### 2.可视化

可视化我们选择 ArcGIS JS API，首先，我们创建一个 WebScene，然后在 SceneView 中显示它：

```js
const webscene = new WebScene({
  ground: {
    opacity: 0 // set transparent ground
  }
})

const view = new SceneView({
  container: 'viewDiv',
  map: webscene,
  qualityProfile: 'high',
  viewingMode: 'local',
  spatialReference: {
    wkid: 2056
  },
  camera: {
    position: { x: 2694307.39164, y: 1245619.17789, z: 100890.937, spatialReference: 2056 },
    heading: 0.0,
    tilt: 0.5
  },
  alphaCompositingEnabled: true, // enable transparent background
  environment: {
    background: {
      type: 'color',
      color: [0, 0, 0, 0] // set background opacity to 0
    },
    starsEnabled: false,
    atmosphereEnabled: false
  },
  constraints: {
    altitude: {
      min: 5000,
      max: 100000
    }
  }
})
```

请注意 `elevationInfo` 使用 Arcade 表达式夸大轮廓线的实际高度。
接下来我们以 symbolLayers 图层的形式添加水多边形，我们使用拉伸多边形来增强 3D 效果：

```js
const renderer = {
  type: 'simple',
  symbol: {
    type: 'polygon-3d',
    symbolLayers: [
      {
        type: 'extrude',
        material: {
          color: [86, 72, 31]
        },
        size: 100
      }
    ]
  }
}
```

然后我们使用带有 IconSymbol3DLayer 的 PointSymbol 渲染山体。这里的重点的是标出主要山体点。在 3D 中可视化文本标签时，我们经常使用标注来避免遮挡并清楚地显示标签指向的位置。另请还要注意添加高程信息，夸大 z 值：

```js
const hillsLayer = new FeatureLayer({
  url:
    'https://services2.arcgis.com/cFEFS0EWrhfDeVw9/arcgis/rest/services/HillsZurichDemo/FeatureServer',
  elevationInfo: {
    mode: 'absolute-height',
    featureExpressionInfo: {
      expression: 'Pow(Geometry($feature).Z, 1.2)'
    }
  },
  renderer: {
    type: 'simple',
    symbol: {
      type: 'point-3d',
      symbolLayers: [
        {
          type: 'icon',
          resource: {
            primitive: 'circle'
          },
          material: {
            color: [86, 72, 31]
          },
          size: '4px'
        }
      ]
    }
  },
  labelingInfo: [
    {
      labelPlacement: 'above-center',
      labelExpressionInfo: {
        expression: '$feature.NAME'
      },
      symbol: {
        type: 'label-3d',
        symbolLayers: [
          {
            type: 'text',
            material: {
              color: [86, 72, 31]
            },
            halo: {
              color: [244, 239, 227, 0.6],
              size: '3px'
            },
            font: {
              weight: 'bold'
            },
            size: 10
          }
        ],
        verticalOffset: {
          screenLength: 50,
          maxWorldLength: 1000,
          minWorldLength: 20
        },
        callout: {
          type: 'line',
          size: '2px',
          color: [86, 72, 31]
        }
      }
    }
  ]
})
webscene.add(hillsLayer)
```

地图目前看起来不错，但引导用户前往我们所渲染的区域会更好。为此，我们将在右侧添加一个面板，其中包含有关该区域的更多信息。我们还会放置用户可以单击的按钮，以便更轻松地导航到主视点。对于我们存储的每个视点，我们可以在浏览器控制台中运行下面这些代码来打印查看摄像机的位置：

```js
const view = require('esri/views/View').views.getItemAt(0)
;(function() {
  const p = view.camera.position

  if (p.spatialReference.isWebMercator || p.spatialReference.isWGS84) {
    console.log(`
{
  position: [
    ${p.longitude.toFixed(8)},
    ${p.latitude.toFixed(8)},
    ${p.z.toFixed(5)}
  ],
  heading: ${view.camera.heading.toFixed(2)},
  tilt: ${view.camera.tilt.toFixed(2)}
}`)
  } else {
    console.log(`
{
  position: {
    x: ${p.x.toFixed(5)},
    y: ${p.y.toFixed(5)},
    z: ${p.z.toFixed(3)},
    spatialReference: ${p.spatialReference.wkid}
  },
  heading: ${view.camera.heading.toFixed(2)},
  tilt: ${view.camera.tilt.toFixed(2)}
}`)
  }
})()
```

现在我们可以将这些摄像机位置绑定到面板中的按钮，以引导用户进入感兴趣的区域：

![图](http://p0.qhimg.com/t01b7ab63f6ec26d3bb.gif)

### 3.最后

在这些代码中我没有对数据的正确性进行判断以及对错误进行处理，但这不是最重要的。

这是创建具有等高线 3D 地图的主要步骤，这里最繁琐的是数据的获取及处理，数据是我们一切工作的基础，在 OpenStreetMap 上有许多免费的数据可以下载，但这只能在学习中使用，不能在项目中应用。

读者们可以按照这个教程随意即兴发挥，将它与其他数据结合起来，并设置你所喜欢的颜色，你将拥有一副独一无二的等高线 3D 地图......
如果你有什么疑问，可以在下方留言告诉我，谢谢。
